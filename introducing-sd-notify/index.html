<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><title>Announcing the sd-notify crate</title><link href=/print.css media=print rel=stylesheet><link href=/poole.css rel=stylesheet><link href=/hyde.css rel=stylesheet><link href=https://blog.dend.ro/atom.xml rel=alternate title=RSS type=application/atom+xml><link href=https://mapstodon.space/@lnicola rel=me><body><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://blog.dend.ro/><h1></h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>Home</a><li class=sidebar-nav-item><a href=/content/blogroll/>Blogroll</a><li class=sidebar-nav-item><a href=/content/acknowledgements/>Acknowledgements</a><li class=sidebar-nav-item><a href=https://www.buymeacoffee.com/lnicolaq>Buy me a â˜•</a></ul></div></div><div class="content container"><div class=post><h1 class=post-title>Announcing the sd-notify crate</h1><span class=post-date>2022-01-12</span><p>This is a quick post announcing the <a href=https://crates.io/crates/sd-notify><code>sd-notify</code></a> crate. <code>sd-notify</code> is a Rust library for interacting with <code>systemd</code> or a compatible service manager.<p>If you're not running Linux or you don't like <code>systemd</code>, this crate is not for you.<h2 id=systemd-in-3-minutes>systemd in 3 minutes</h2><p>Assuming you are running <code>systemd</code>, at some point you might find yourself with a program you want to automatically run on start-up. Historically, this meant doing an intricate dance which includes calling <code>fork()</code> twice and writing your PID to a file, but fortunately, with <code>systemd</code> this is no longer required and is actually discouraged.<p>You can take your plain console application and make a <code>systemd</code> unit for it:<pre class=language-ini data-lang=ini style=background-color:#2b303b;color:#c0c5ce;><code class=language-ini data-lang=ini><span style=color:#b48ead;>[Unit]
</span><span style=color:#bf616a;>Description</span><span>=Monitors room temperature
</span><span>
</span><span style=color:#b48ead;>[Service]
</span><span style=color:#bf616a;>User</span><span>=stats
</span><span style=color:#bf616a;>ExecStart</span><span>=/usr/local/bin/monitor-temperature
</span><span style=color:#bf616a;>Restart</span><span>=on-failure
</span><span style=color:#bf616a;>RestartSec</span><span>=</span><span style=color:#d08770;>10
</span><span>
</span><span style=color:#b48ead;>[Install]
</span><span style=color:#bf616a;>WantedBy</span><span>=default.target
</span></code></pre><p>You then drop that file under <code>/etc/systemd/system/monitor-temperature.service</code>, run <code>systemctl daemon-reload</code>, <code>systemctl enable --now monitor-temperature</code> and you're done.<p>For the effort, you get logs (<code>journalctl -efu monitor-temperature</code>), precise child process tracking (using control groups), CPU, memory and I/O accounting, automatic restarts, and a way to manage your service across all the popular Linux distros.<h2 id=systemd-start-up-types>systemd start-up types</h2><p>If your daemon has a long start-up sequence, <code>systemd</code> can tell you whether it is ready or not. In order to do that, you can set the <code>Type</code> clause.<p>The simplest, and also the default, option is called <code>simple</code>. It means that the daemon is marked as ready right after it starts. Another useful option is <code>forking</code>, which means that the service does the classic double-fork dance. You can read more about these two (any many others) in your <a href=https://www.freedesktop.org/software/systemd/man/systemd.service.html><code>systemd.service</code></a> documentation page.<p>What the <code>sd-notify</code> crate helps with is the <code>notify</code> start-up type. This lets you do whatever initialization you want, then notify <code>systemd</code> that you are ready by sending a over a Unix socket. Services can also say that they are reloading their settings, stopping, or even set a status message. The protocol is described in detail <a href=https://www.freedesktop.org/software/systemd/man/sd_notify.html>here</a>.<h2 id=using-sd-notify>Using sd-notify</h2><p>The basic usage is quite simple. You do your initialization steps, then call:<pre class=language-rust data-lang=rust style=background-color:#2b303b;color:#c0c5ce;><code class=language-rust data-lang=rust><span style=color:#b48ead;>let </span><span>_ = sd_notify::notify(</span><span style=color:#d08770;>true</span><span>, &[NotifyState::Ready]);
</span></code></pre><p>That's all and now your daemon only shows as "running" when it finished starting up.<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#bf616a;>$</span><span> systemctl status monitor-temperature
</span><span>     </span><span style=color:#bf616a;>Active:</span><span> activating (start) </span><span style=color:#bf616a;>since</span><span> Wed 2022-01-12 20:36:02 EET; </span><span style=color:#bf616a;>9s</span><span> ago
</span><span>     </span><span style=color:#bf616a;>[snip]
</span><span style=color:#bf616a;>$</span><span> systemctl status monitor-temperature
</span><span>     </span><span style=color:#bf616a;>Active:</span><span> active (running) </span><span style=color:#bf616a;>since</span><span> Wed 2022-01-12 20:36:12 EET; </span><span style=color:#bf616a;>2s</span><span> ago
</span><span>     </span><span style=color:#bf616a;>[snip]
</span></code></pre><p>You can also include a status message:<pre class=language-rust data-lang=rust style=background-color:#2b303b;color:#c0c5ce;><code class=language-rust data-lang=rust><span style=color:#b48ead;>let </span><span>_ = sd_notify::notify(
</span><span>    </span><span style=color:#d08770;>true</span><span>,
</span><span>    &[
</span><span>        NotifyState::Ready,
</span><span>        NotifyState::Status("</span><span style=color:#a3be8c;>Monitoring room temperature</span><span>"),
</span><span>    ],
</span><span>);
</span></code></pre><pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#bf616a;>$</span><span> systemctl status monitor-temperature
</span><span>     </span><span style=color:#bf616a;>Active:</span><span> active (running) </span><span style=color:#bf616a;>since</span><span> Wed 2022-01-12 20:41:46 EET; </span><span style=color:#bf616a;>782ms</span><span> ago
</span><span>     </span><span style=color:#bf616a;>Status: </span><span>"</span><span style=color:#a3be8c;>Monitoring room temperature</span><span>"
</span><span>     </span><span style=color:#bf616a;>[snip]
</span></code></pre><p>There's also one advanced feature: you can retrieve file descriptors passed by the service manager, for socket-activated daemons. You can read more on it <a href=https://www.freedesktop.org/software/systemd/man/sd_listen_fds.html>here</a>.<h2 id=final-words>Final words</h2><p><code>sd-notify</code> is written in pure Rust, has no dependencies and is available under a permissive license (MIT or Apache-2.0). My intention is that it stays lightweight, but I'm not necessarily opposed to adding more features.<p>If you want more functionality today, try the <a href=https://crates.io/crates/libsystemd><code>libsystemd</code></a> or <a href=https://crates.io/crates/systemd><code>rust-systemd</code></a> crates.</div></div>